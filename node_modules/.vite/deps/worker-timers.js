import "./chunk-ROME4SDB.js";

// node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js
var createAddUniqueNumber = (generateUniqueNumber2) => {
  return (set) => {
    const number = generateUniqueNumber2(set);
    set.add(number);
    return number;
  };
};

// node_modules/fast-unique-numbers/build/es2019/factories/cache.js
var createCache = (lastNumberWeakMap) => {
  return (collection, nextNumber) => {
    lastNumberWeakMap.set(collection, nextNumber);
    return nextNumber;
  };
};

// node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
var createGenerateUniqueNumber = (cache2, lastNumberWeakMap) => {
  return (collection) => {
    const lastNumber = lastNumberWeakMap.get(collection);
    let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
    if (!collection.has(nextNumber)) {
      return cache2(collection, nextNumber);
    }
    if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
      while (collection.has(nextNumber)) {
        nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
      }
      return cache2(collection, nextNumber);
    }
    if (collection.size > MAX_SAFE_INTEGER) {
      throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
    }
    while (collection.has(nextNumber)) {
      nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
    }
    return cache2(collection, nextNumber);
  };
};

// node_modules/fast-unique-numbers/build/es2019/module.js
var LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
var cache = createCache(LAST_NUMBER_WEAK_MAP);
var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);

// node_modules/worker-timers-broker/build/es2019/guards/call-notification.js
var isCallNotification = (message) => {
  return message.method !== void 0 && message.method === "call";
};

// node_modules/worker-timers-broker/build/es2019/guards/clear-response.js
var isClearResponse = (message) => {
  return message.error === null && typeof message.id === "number";
};

// node_modules/worker-timers-broker/build/es2019/module.js
var load = (url) => {
  const scheduledIntervalFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const scheduledTimeoutFunctions = /* @__PURE__ */ new Map([[0, () => {
  }]]);
  const unrespondedRequests = /* @__PURE__ */ new Map();
  const worker2 = new Worker(url);
  worker2.addEventListener("message", ({ data }) => {
    if (isCallNotification(data)) {
      const { params: { timerId, timerType } } = data;
      if (timerType === "interval") {
        const idOrFunc = scheduledIntervalFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      } else if (timerType === "timeout") {
        const idOrFunc = scheduledTimeoutFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
          if (timerIdAndTimerType === void 0 || timerIdAndTimerType.timerId !== timerId || timerIdAndTimerType.timerType !== timerType) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
          scheduledTimeoutFunctions.delete(timerId);
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      }
    } else if (isClearResponse(data)) {
      const { id } = data;
      const timerIdAndTimerType = unrespondedRequests.get(id);
      if (timerIdAndTimerType === void 0) {
        throw new Error("The timer is in an undefined state.");
      }
      const { timerId, timerType } = timerIdAndTimerType;
      unrespondedRequests.delete(id);
      if (timerType === "interval") {
        scheduledIntervalFunctions.delete(timerId);
      } else {
        scheduledTimeoutFunctions.delete(timerId);
      }
    } else {
      const { error: { message } } = data;
      throw new Error(message);
    }
  });
  const clearInterval2 = (timerId) => {
    const id = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id, { timerId, timerType: "interval" });
    scheduledIntervalFunctions.set(timerId, id);
    worker2.postMessage({
      id,
      method: "clear",
      params: { timerId, timerType: "interval" }
    });
  };
  const clearTimeout2 = (timerId) => {
    const id = generateUniqueNumber(unrespondedRequests);
    unrespondedRequests.set(id, { timerId, timerType: "timeout" });
    scheduledTimeoutFunctions.set(timerId, id);
    worker2.postMessage({
      id,
      method: "clear",
      params: { timerId, timerType: "timeout" }
    });
  };
  const setInterval2 = (func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledIntervalFunctions);
    scheduledIntervalFunctions.set(timerId, () => {
      func();
      if (typeof scheduledIntervalFunctions.get(timerId) === "function") {
        worker2.postMessage({
          id: null,
          method: "set",
          params: {
            delay,
            now: performance.now(),
            timerId,
            timerType: "interval"
          }
        });
      }
    });
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "interval"
      }
    });
    return timerId;
  };
  const setTimeout3 = (func, delay = 0) => {
    const timerId = generateUniqueNumber(scheduledTimeoutFunctions);
    scheduledTimeoutFunctions.set(timerId, func);
    worker2.postMessage({
      id: null,
      method: "set",
      params: {
        delay,
        now: performance.now(),
        timerId,
        timerType: "timeout"
      }
    });
    return timerId;
  };
  return {
    clearInterval: clearInterval2,
    clearTimeout: clearTimeout2,
    setInterval: setInterval2,
    setTimeout: setTimeout3
  };
};

// node_modules/worker-timers/build/es2019/factories/load-or-return-broker.js
var createLoadOrReturnBroker = (loadBroker, worker2) => {
  let broker = null;
  return () => {
    if (broker !== null) {
      return broker;
    }
    const blob = new Blob([worker2], { type: "application/javascript; charset=utf-8" });
    const url = URL.createObjectURL(blob);
    broker = loadBroker(url);
    setTimeout(() => URL.revokeObjectURL(url));
    return broker;
  };
};

// node_modules/worker-timers/build/es2019/worker/worker.js
var worker = `(()=>{"use strict";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:"call",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener("message",(i=>{let{data:s}=i;try{if("clear"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if("interval"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id "'.concat(t,'".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if("timeout"!==i)throw new Error('The given type "'.concat(i,'" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if("set"!==s.method)throw new Error('The given method "'.concat(s.method,'" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if("interval"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,"interval"))})(i,a,n);else{if("timeout"!==d)throw new Error('The given type "'.concat(d,'" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,"timeout"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`;

// node_modules/worker-timers/build/es2019/module.js
var loadOrReturnBroker = createLoadOrReturnBroker(load, worker);
var clearInterval = (timerId) => loadOrReturnBroker().clearInterval(timerId);
var clearTimeout = (timerId) => loadOrReturnBroker().clearTimeout(timerId);
var setInterval = (...args) => loadOrReturnBroker().setInterval(...args);
var setTimeout2 = (...args) => loadOrReturnBroker().setTimeout(...args);
export {
  clearInterval,
  clearTimeout,
  setInterval,
  setTimeout2 as setTimeout
};
//# sourceMappingURL=worker-timers.js.map
