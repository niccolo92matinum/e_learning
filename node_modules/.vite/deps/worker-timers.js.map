{
  "version": 3,
  "sources": ["../../fast-unique-numbers/src/factories/add-unique-number.ts", "../../fast-unique-numbers/src/factories/cache.ts", "../../fast-unique-numbers/src/factories/generate-unique-number.ts", "../../fast-unique-numbers/src/module.ts", "../../worker-timers-broker/src/guards/call-notification.ts", "../../worker-timers-broker/src/guards/clear-response.ts", "../../worker-timers-broker/src/module.ts", "../../worker-timers/src/factories/load-or-return-broker.ts", "../../worker-timers/src/worker/worker.ts", "../../worker-timers/src/module.ts"],
  "sourcesContent": ["import { TAddUniqueNumberFactory } from '../types';\n\nexport const createAddUniqueNumber: TAddUniqueNumberFactory = (generateUniqueNumber) => {\n    return (set) => {\n        const number = generateUniqueNumber(set);\n\n        set.add(number);\n\n        return number;\n    };\n};\n", "import { TCacheFactory } from '../types';\n\nexport const createCache: TCacheFactory = (lastNumberWeakMap) => {\n    return (collection, nextNumber) => {\n        lastNumberWeakMap.set(collection, nextNumber);\n\n        return nextNumber;\n    };\n};\n", "import { TGenerateUniqueNumberFactory } from '../types';\n\n/*\n * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it\n * is fairly new.\n */\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;\nconst TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;\nconst TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;\n\nexport const createGenerateUniqueNumber: TGenerateUniqueNumberFactory = (cache, lastNumberWeakMap) => {\n    return (collection) => {\n        const lastNumber = lastNumberWeakMap.get(collection);\n\n        /*\n         * Let's try the cheapest algorithm first. It might fail to produce a new\n         * number, but it is so cheap that it is okay to take the risk. Just\n         * increase the last number by one or reset it to 0 if we reached the upper\n         * bound of SMIs (which stands for small integers). When the last number is\n         * unknown it is assumed that the collection contains zero based consecutive\n         * numbers.\n         */\n        let nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;\n\n        if (!collection.has(nextNumber)) {\n            return cache(collection, nextNumber);\n        }\n\n        /*\n         * If there are less than half of 2 ** 30 numbers stored in the collection,\n         * the chance to generate a new random number in the range from 0 to 2 ** 30\n         * is at least 50%. It's benifitial to use only SMIs because they perform\n         * much better in any environment based on V8.\n         */\n        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {\n            while (collection.has(nextNumber)) {\n                nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);\n            }\n\n            return cache(collection, nextNumber);\n        }\n\n        // Quickly check if there is a theoretical chance to generate a new number.\n        if (collection.size > MAX_SAFE_INTEGER) {\n            throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');\n        }\n\n        // Otherwise use the full scale of safely usable integers.\n        while (collection.has(nextNumber)) {\n            nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);\n        }\n\n        return cache(collection, nextNumber);\n    };\n};\n", "import { createAddUniqueNumber } from './factories/add-unique-number';\nimport { createCache } from './factories/cache';\nimport { createGenerateUniqueNumber } from './factories/generate-unique-number';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './types/index';\n\nconst LAST_NUMBER_WEAK_MAP = new WeakMap<Map<number, any> | Set<number>, number>();\n\nconst cache = createCache(LAST_NUMBER_WEAK_MAP);\nconst generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);\nconst addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);\n\nexport { addUniqueNumber, generateUniqueNumber };\n", "import { ICallNotification, TWorkerMessage } from 'worker-timers-worker';\n\nexport const isCallNotification = (message: TWorkerMessage): message is ICallNotification => {\n    return (<ICallNotification>message).method !== undefined && (<ICallNotification>message).method === 'call';\n};\n", "import { IClearResponse, TWorkerMessage } from 'worker-timers-worker';\n\nexport const isClearResponse = (message: TWorkerMessage): message is IClearResponse => {\n    return (<IClearResponse>message).error === null && typeof message.id === 'number';\n};\n", "import { generateUniqueNumber } from 'fast-unique-numbers';\nimport { IClearRequest, ISetNotification, IWorkerEvent, TTimerType } from 'worker-timers-worker';\nimport { isCallNotification } from './guards/call-notification';\nimport { isClearResponse } from './guards/clear-response';\n\nexport const load = (url: string) => {\n    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.\n    const scheduledIntervalFunctions: Map<number, number | Function> = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n    const scheduledTimeoutFunctions: Map<number, number | Function> = new Map([[0, () => {}]]); // tslint:disable-line no-empty\n    const unrespondedRequests: Map<number, { timerId: number; timerType: TTimerType }> = new Map();\n\n    const worker = new Worker(url);\n\n    worker.addEventListener('message', ({ data }: IWorkerEvent) => {\n        if (isCallNotification(data)) {\n            const {\n                params: { timerId, timerType }\n            } = data;\n\n            if (timerType === 'interval') {\n                const idOrFunc = scheduledIntervalFunctions.get(timerId);\n\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n\n                    if (\n                        timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType\n                    ) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                } else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n                } else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            } else if (timerType === 'timeout') {\n                const idOrFunc = scheduledTimeoutFunctions.get(timerId);\n\n                if (typeof idOrFunc === 'number') {\n                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);\n\n                    if (\n                        timerIdAndTimerType === undefined ||\n                        timerIdAndTimerType.timerId !== timerId ||\n                        timerIdAndTimerType.timerType !== timerType\n                    ) {\n                        throw new Error('The timer is in an undefined state.');\n                    }\n                } else if (typeof idOrFunc !== 'undefined') {\n                    idOrFunc();\n\n                    // A timeout can be savely deleted because it is only called once.\n                    scheduledTimeoutFunctions.delete(timerId);\n                } else {\n                    throw new Error('The timer is in an undefined state.');\n                }\n            }\n        } else if (isClearResponse(data)) {\n            const { id } = data;\n\n            const timerIdAndTimerType = unrespondedRequests.get(id);\n\n            if (timerIdAndTimerType === undefined) {\n                throw new Error('The timer is in an undefined state.');\n            }\n\n            const { timerId, timerType } = timerIdAndTimerType;\n\n            unrespondedRequests.delete(id);\n\n            if (timerType === 'interval') {\n                scheduledIntervalFunctions.delete(timerId);\n            } else {\n                scheduledTimeoutFunctions.delete(timerId);\n            }\n        } else {\n            const {\n                error: { message }\n            } = data;\n\n            throw new Error(message);\n        }\n    });\n\n    const clearInterval = (timerId: number) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n\n        unrespondedRequests.set(id, { timerId, timerType: 'interval' });\n        scheduledIntervalFunctions.set(timerId, id);\n\n        worker.postMessage(<IClearRequest>{\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'interval' }\n        });\n    };\n\n    const clearTimeout = (timerId: number) => {\n        const id = generateUniqueNumber(unrespondedRequests);\n\n        unrespondedRequests.set(id, { timerId, timerType: 'timeout' });\n        scheduledTimeoutFunctions.set(timerId, id);\n\n        worker.postMessage(<IClearRequest>{\n            id,\n            method: 'clear',\n            params: { timerId, timerType: 'timeout' }\n        });\n    };\n\n    const setInterval = (func: Function, delay = 0) => {\n        const timerId = generateUniqueNumber(scheduledIntervalFunctions);\n\n        scheduledIntervalFunctions.set(timerId, () => {\n            func();\n\n            // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().\n            if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {\n                worker.postMessage(<ISetNotification>{\n                    id: null,\n                    method: 'set',\n                    params: {\n                        delay,\n                        now: performance.now(),\n                        timerId,\n                        timerType: 'interval'\n                    }\n                });\n            }\n        });\n\n        worker.postMessage(<ISetNotification>{\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'interval'\n            }\n        });\n\n        return timerId;\n    };\n\n    const setTimeout = (func: Function, delay = 0) => {\n        const timerId = generateUniqueNumber(scheduledTimeoutFunctions);\n\n        scheduledTimeoutFunctions.set(timerId, func);\n\n        worker.postMessage(<ISetNotification>{\n            id: null,\n            method: 'set',\n            params: {\n                delay,\n                now: performance.now(),\n                timerId,\n                timerType: 'timeout'\n            }\n        });\n\n        return timerId;\n    };\n\n    return {\n        clearInterval,\n        clearTimeout,\n        setInterval,\n        setTimeout\n    };\n};\n", "export const createLoadOrReturnBroker = <Broker>(loadBroker: (url: string) => Broker, worker: string) => {\n    let broker: null | Broker = null;\n\n    return () => {\n        if (broker !== null) {\n            return broker;\n        }\n\n        const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });\n        const url = URL.createObjectURL(blob);\n\n        broker = loadBroker(url);\n\n        // Bug #1: Edge up until v18 didn't like the URL to be revoked directly.\n        setTimeout(() => URL.revokeObjectURL(url));\n\n        return broker;\n    };\n};\n", "// This is the minified and stringified code of the worker-timers-worker package.\nexport const worker = `(()=>{\"use strict\";const e=new Map,t=new Map,r=(e,t)=>{let r,o;const i=performance.now();r=i,o=e-Math.max(0,i-t);return{expected:r+o,remainingDelay:o}},o=(e,t,r,i)=>{const s=performance.now();s>r?postMessage({id:null,method:\"call\",params:{timerId:t,timerType:i}}):e.set(t,setTimeout(o,r-s,e,t,r,i))};addEventListener(\"message\",(i=>{let{data:s}=i;try{if(\"clear\"===s.method){const{id:r,params:{timerId:o,timerType:i}}=s;if(\"interval\"===i)(t=>{const r=e.get(t);if(void 0===r)throw new Error('There is no interval scheduled with the given id \"'.concat(t,'\".'));clearTimeout(r),e.delete(t)})(o),postMessage({error:null,id:r});else{if(\"timeout\"!==i)throw new Error('The given type \"'.concat(i,'\" is not supported'));(e=>{const r=t.get(e);if(void 0===r)throw new Error('There is no timeout scheduled with the given id \"'.concat(e,'\".'));clearTimeout(r),t.delete(e)})(o),postMessage({error:null,id:r})}}else{if(\"set\"!==s.method)throw new Error('The given method \"'.concat(s.method,'\" is not supported'));{const{params:{delay:i,now:n,timerId:a,timerType:d}}=s;if(\"interval\"===d)((t,i,s)=>{const{expected:n,remainingDelay:a}=r(t,s);e.set(i,setTimeout(o,a,e,i,n,\"interval\"))})(i,a,n);else{if(\"timeout\"!==d)throw new Error('The given type \"'.concat(d,'\" is not supported'));((e,i,s)=>{const{expected:n,remainingDelay:a}=r(e,s);t.set(i,setTimeout(o,a,t,i,n,\"timeout\"))})(i,a,n)}}}}catch(e){postMessage({error:{message:e.message},id:s.id,result:null})}}))})();`; // tslint:disable-line:max-line-length\n", "import { load } from 'worker-timers-broker';\nimport { createLoadOrReturnBroker } from './factories/load-or-return-broker';\nimport { worker } from './worker/worker';\n\nconst loadOrReturnBroker = createLoadOrReturnBroker(load, worker);\n\nexport const clearInterval: ReturnType<typeof load>['clearInterval'] = (timerId) => loadOrReturnBroker().clearInterval(timerId);\n\nexport const clearTimeout: ReturnType<typeof load>['clearTimeout'] = (timerId) => loadOrReturnBroker().clearTimeout(timerId);\n\nexport const setInterval: ReturnType<typeof load>['setInterval'] = (...args) => loadOrReturnBroker().setInterval(...args);\n\nexport const setTimeout: ReturnType<typeof load>['setTimeout'] = (...args) => loadOrReturnBroker().setTimeout(...args);\n"],
  "mappings": "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",
  "names": ["generateUniqueNumber", "cache", "worker", "clearInterval", "clearTimeout", "setInterval", "setTimeout", "worker", "setTimeout"]
}
